<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <script src="https://mozilla.github.io/pdf.js/build/pdf.js"></script>
  <title>File Reader</title>
</head>

<body>
  <div class="nav-bar">
    <div id="file-menu">
      <img id="logoimg" src="images/logo.png">
      <button id="file-btn">File</button>
      <button id="chat-btn">Edit</button>
      <button id="file-btn">Help</button>
    </div>
  </div>

  <div id="file-submenu">
    <div id="new-tab-btn" class="menu-item">Open New File</div>
    <div id="new-tab-btn" class="menu-item">Open Folder</div>
    <div id="exit-tab-btn" class="menu-item">Exit</div>
  </div>

  <div id="chat-submenu">
    <div id="chat-tab-history" class="menu-item">View Chat History</div>
    <div id="chat-tab-history" class="menu-item">Save Chat</div>
    <div id="chat-tab-history" class="menu-item">Manage Context</div>
    <div id="chat-tab-history" class="menu-item">Clear Chat</div>
  </div>


  <div class="workbench-container">
    <div class="icon-tooltip">
      <svg xmlns="http://www.w3.org/2000/svg" width="50%" height="auto" fill="#dcedff"
        class="bi bi-archive" viewBox="0 0 16 16">
        <path d="M0 2a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1v7.5a2.5 2.5 0 0 1-2.5 2.5h-9A2.5 2.5 0 0 1 1 12.5V5a1 1 0 0 1-1-1zm2 3v7.5A1.5 1.5 0 0 0 3.5 14h9a1.5 1.5 0 0 0 1.5-1.5V5zm13-3H1v2h14zM5 7.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5"/>
</svg>
      <span class="tooltip-text">Manage Context</span>
    </div>

    <div class="icon-tooltip">
      <svg xmlns="http://www.w3.org/2000/svg" width="50%" height="auto" fill="#dcedff"
        class="bi bi-clock" viewBox="0 0 16 16">
          <path d="M8.515 1.019A7 7 0 0 0 8 1V0a8 8 0 0 1 .589.022zm2.004.45a7 7 0 0 0-.985-.299l.219-.976q.576.129 1.126.342zm1.37.71a7 7 0 0 0-.439-.27l.493-.87a8 8 0 0 1 .979.654l-.615.789a7 7 0 0 0-.418-.302zm1.834 1.79a7 7 0 0 0-.653-.796l.724-.69q.406.429.747.91zm.744 1.352a7 7 0 0 0-.214-.468l.893-.45a8 8 0 0 1 .45 1.088l-.95.313a7 7 0 0 0-.179-.483m.53 2.507a7 7 0 0 0-.1-1.025l.985-.17q.1.58.116 1.17zm-.131 1.538q.05-.254.081-.51l.993.123a8 8 0 0 1-.23 1.155l-.964-.267q.069-.247.12-.501m-.952 2.379q.276-.436.486-.908l.914.405q-.24.54-.555 1.038zm-.964 1.205q.183-.183.35-.378l.758.653a8 8 0 0 1-.401.432z"/>
  <path d="M8 1a7 7 0 1 0 4.95 11.95l.707.707A8.001 8.001 0 1 1 8 0z"/>
  <path d="M7.5 3a.5.5 0 0 1 .5.5v5.21l3.248 1.856a.5.5 0 0 1-.496.868l-3.5-2A.5.5 0 0 1 7 9V3.5a.5.5 0 0 1 .5-.5"/>
</svg>
      <span class="tooltip-text">View Chat History</span>
    </div>

    <div class="icon-tooltip">
      <svg xmlns="http://www.w3.org/2000/svg" width="50%" height="auto" fill="#dcedff" class="bi bi-floppy" viewBox="0 0 16 16">
  <path d="M11 2H9v3h2z"/>
  <path d="M1.5 0h11.586a1.5 1.5 0 0 1 1.06.44l1.415 1.414A1.5 1.5 0 0 1 16 2.914V14.5a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 14.5v-13A1.5 1.5 0 0 1 1.5 0M1 1.5v13a.5.5 0 0 0 .5.5H2v-4.5A1.5 1.5 0 0 1 3.5 9h9a1.5 1.5 0 0 1 1.5 1.5V15h.5a.5.5 0 0 0 .5-.5V2.914a.5.5 0 0 0-.146-.353l-1.415-1.415A.5.5 0 0 0 13.086 1H13v4.5A1.5 1.5 0 0 1 11.5 7h-7A1.5 1.5 0 0 1 3 5.5V1H1.5a.5.5 0 0 0-.5.5m3 4a.5.5 0 0 0 .5.5h7a.5.5 0 0 0 .5-.5V1H4zM3 15h10v-4.5a.5.5 0 0 0-.5-.5h-9a.5.5 0 0 0-.5.5z"/>
</svg>
      <span class="tooltip-text">Save Chat</span>
    </div>
  </div>

  <div class="page-layout">

    <div class="file-container">
      <div id="tab-bar"></div>
      <div id="drop-area">Drag & Drop a text file here or click to upload</div>
      <input type="file" id="file-input" accept=".txt,.md,.doc,.docx,.pdf,.rtf,.odt,.html,.htm" style="display:none" />
      <div id="file-content">No file loaded yet.</div>
    </div>

    <div class="chat-container">
      <div class="model-container">
        <select id="model-select">
          <option value="LangChainKVCache/meta-llama/Llama-3.1-8B-Instruct">
            LangChainKVCache/meta-llama/Llama-3.1-8B-Instruct</option>
          <option value="HuggingFaceNoCache/meta-llama/Llama-3.1-8B-Instruct">
            HuggingFaceNoCache/meta-llama/Llama-3.1-8B-Instruct</option>
          <option value="LangChainKVCache/meta-llama/Llama-3.2-1B-Instruct">
            LangChainKVCache/meta-llama/Llama-3.2-1B-Instruct</option>
          <option value="HuggingFaceNoCache/meta-llama/Llama-3.2-1B-Instruct">
            HuggingFaceNoCache/meta-llama/Llama-3.2-1B-Instruct</option>
          <option value="LangChainKVCache/TinyLlama/TinyLlama-1.1B-Chat-v1.0">
            LangChainKVCache/TinyLlama/TinyLlama-1.1B-Chat-v1.0</option>
          <option value="HuggingFaceNoCache/TinyLlama/TinyLlama-1.1B-Chat-v1.0">
            HuggingFaceNoCache/TinyLlama/TinyLlama-1.1B-Chat-v1.0</option>
        </select>
      </div>

      <h2 id="file-name-display">No file loaded</h2>

      <div id="chat-output"></div>

      <div id="chat-controls">
        <input type="text" id="ai-input" placeholder="Ask AI anything..." />
        <button id="ai-send" aria-label="Send">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="#007bff"
            class="bi bi-arrow-up-circle-fill" viewBox="0 0 16 16">
            <path
              d="M16 8A8 8 0 1 0 0 8a8 8 0 0 0 16 0m-7.5 3.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708l3-3a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707z" />
          </svg>
        </button>

      </div>
    </div>
  </div>
  <div class="footer-container">
    <img src="images/logo.png">
  </div>



  <script>
    const dropArea = document.getElementById('drop-area');
    const fileInput = document.getElementById('file-input');
    const fileContentDiv = document.getElementById('file-content');
    const chatOutput = document.getElementById('chat-output');
    const aiInput = document.getElementById('ai-input');
    const sendButton = document.getElementById('ai-send');
    const tabBar = document.getElementById('tab-bar');
    const modelSelect = document.getElementById('model-select');

    const fileBtn = document.getElementById('file-btn');
    const fileSubmenu = document.getElementById('file-submenu');

    const chatBtn = document.getElementById('chat-btn');
    const chatSubmenu = document.getElementById('chat-submenu');

    document.getElementById("exit-tab-btn").addEventListener("click", function () {
      window.close();
    });
    document.getElementById('new-tab-btn').addEventListener('click', () => {
      fileInput.click();
    });


    let activeSubmenu = null;

    // Toggle submenu visibility
    function toggleSubmenu(button, submenu) {
      if (activeSubmenu && activeSubmenu !== submenu) {
        activeSubmenu.style.display = 'none';
      }

      const isVisible = submenu.style.display === 'block';
      submenu.style.display = isVisible ? 'none' : 'block';
      activeSubmenu = submenu.style.display === 'block' ? submenu : null;
    }

    // Handle file button click
    fileBtn.addEventListener('click', (event) => {
      event.stopPropagation();
      fileBtn.classList.add("active");
      chatBtn.classList.remove("active");
      toggleSubmenu(fileBtn, fileSubmenu);
    });

    // Handle chat button click
    chatBtn.addEventListener('click', (event) => {
      event.stopPropagation();
      chatBtn.classList.add("active");
      fileBtn.classList.remove("active");
      toggleSubmenu(chatBtn, chatSubmenu);
    });

    // Close submenu when clicking outside
    document.addEventListener('click', () => {
      if (activeSubmenu) {
        activeSubmenu.style.display = 'none';
        activeSubmenu = null;
      }
    });

    // Prevent closing when clicking inside submenus
    fileSubmenu.addEventListener('click', (event) => event.stopPropagation());
    chatSubmenu.addEventListener('click', (event) => event.stopPropagation());

    let previousModelValue = modelSelect.value;

    modelSelect.addEventListener('change', async () => {
      if (!currentTabId) {
        alert('No active tab. Please load a file first.');
        modelSelect.value = previousModelValue;
        return;
      }

      const tab = tabs.find(t => t.id === currentTabId);
      if (!tab) return;

      const newModelValue = modelSelect.value;

      const confirmSwitch = confirm(
        `Switch to model:\n"${newModelValue}"?\n\nThis will start a new chat and delete chat history.`
      );

      if (!confirmSwitch) {
        modelSelect.value = previousModelValue;
        return;
      }

      // üßπ Delete old session from server
      await deleteSessionOnServer(tab.sessionId);

      // üîÅ Assign new sessionId
      tab.sessionId = createSessionId();

      // üîÑ Reset chat state
      tab.chatHistory = [];
      tab.modelSelected = false;
      chatOutput.innerHTML = '';

      // üîß Update tab's model
      tab.model = newModelValue;

      // üì° Call backend to select new model
      const success = await selectModelForSession();

      if (success) {
        tab.modelSelected = true;
        previousModelValue = newModelValue;

        // Optional: show confirmation
        console.log(`‚úÖ Switched to model: ${newModelValue}`);

        // <== ADD THIS PART HERE
        aiInput.disabled = false;  // make sure input is enabled
        aiInput.focus();           // set focus so user can start typing immediately

      } else {
        modelSelect.value = previousModelValue;
        alert('Failed to switch model. Reverting selection.');
      }
    });



    let tabs = [];
    let currentTabId = null;

    async function handlePdf(file) {
      const reader = new FileReader();

      reader.onload = async function (event) {
        const typedArray = new Uint8Array(event.target.result);

        try {
          const pdf = await pdfjsLib.getDocument(typedArray).promise;
          let text = "";

          for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
            const page = await pdf.getPage(pageNum);
            const content = await page.getTextContent();
            const strings = content.items.map(item => item.str);
            text += strings.join(" ") + "\n\n";
          }

          createTab(file.name, text);
        } catch (error) {
          alert("Error reading PDF file: " + error);
        }
      };

      reader.readAsArrayBuffer(file);
    }

    function handleDocx(file) {
      const reader = new FileReader();
      reader.onload = function (event) {
        const arrayBuffer = event.target.result;
        mammoth.extractRawText({ arrayBuffer: arrayBuffer })
          .then(result => {
            createTab(file.name, result.value);
          })
          .catch(err => {
            alert("Error reading DOCX file: " + err);
          });
      };
      reader.readAsArrayBuffer(file);
    }

    function createSessionId() {
      return new Date().toISOString().replace(/[-:.TZ]/g, '') + Math.floor(Math.random() * 1000);
    }

    // Call /select_model to set the model for the session (hardcoded to LangChainKVCache)
    async function selectModelForSession() {
      try {
        // Get the selected model value from the dropdown
        const modelSelect = document.getElementById('model-select');
        const selectedModel = modelSelect.value;

        const response = await fetch('http://127.0.0.1:5000/select_model', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            modelType: selectedModel // use selected option's value here
          })
        });

        if (!response.ok) throw new Error(`Model selection failed: ${response.statusText}`);
        const data = await response.json();
        console.log(`Model selected for session:`, data);
        return true;
      } catch (err) {
        console.error('Error selecting model:', err);
        return false;
      }
    }

    // Create new tab and select model for session
    async function createTab(fileName, fileText) {
      const id = Date.now().toString();
      const sessionId = createSessionId();
      tabs.push({
        id,
        sessionId,
        name: fileName,
        content: fileText,
        chatHistory: [],
        modelSelected: false,
        model: modelSelect.value // üëà NEW!
      });

      renderTabs();
      switchTab(id);

      // No need to select model for new session, as it's global
      // The model context will be created on the first chat message
    }

    function handleFile(file) {
      const ext = file.name.split('.').pop().toLowerCase();

      if (ext === 'docx') {
        handleDocx(file);
      } else if (ext === 'pdf') {
        handlePdf(file);
      } else if (['txt', 'md', 'doc', 'rtf', 'odt', 'html', 'htm'].includes(ext)) {
        // treat as plain text or HTML
        const reader = new FileReader();
        reader.onload = e => {
          createTab(file.name, e.target.result);
        };
        reader.readAsText(file);
      } else {
        alert('Unsupported file type!');
      }
    }

    function renderTabs() {
      tabBar.innerHTML = '';
      tabs.forEach(tab => {
        const tabEl = document.createElement('div');
        tabEl.className = 'tab' + (tab.id === currentTabId ? ' active' : '');
        tabEl.textContent = tab.name;
        tabEl.dataset.id = tab.id;

        // Close button
        const closeBtn = document.createElement('span');
        closeBtn.textContent = '√ó';
        closeBtn.className = 'close-btn';
        closeBtn.onclick = e => {
          e.stopPropagation();
          closeTab(tab.id);
        };
        tabEl.appendChild(closeBtn);

        tabEl.onclick = () => switchTab(tab.id);

        tabBar.appendChild(tabEl);
      });
    }

    // Switch tabs
    function switchTab(id) {
      currentTabId = id;
      const tab = tabs.find(t => t.id === id);
      if (!tab) return;

      fileContentDiv.textContent = tab.content || 'File is empty.';

      const fileNameDisplay = document.getElementById('file-name-display');
      fileNameDisplay.textContent = tab.name;

      renderChatHistory(tab.chatHistory);
      aiInput.value = '';
      renderTabs();
    }

    async function deleteSessionOnServer(sessionId) {
      try {
        const response = await fetch('http://127.0.0.1:5000/delete_session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId })
        });
        if (!response.ok) {
          const errData = await response.json();
          throw new Error(errData.error || 'Failed to delete session');
        }
        console.log(`Session ${sessionId} deleted on server.`);
      } catch (error) {
        console.warn(`Error deleting session ${sessionId}:`, error);
      }
    }

    function closeTab(id) {
      const idx = tabs.findIndex(t => t.id === id);
      if (idx === -1) return;

      // Call backend to delete session
      deleteSessionOnServer(tabs[idx].sessionId);

      tabs.splice(idx, 1);
      if (currentTabId === id) {
        if (tabs.length > 0) {
          switchTab(tabs[Math.max(idx - 1, 0)].id);
        } else {
          currentTabId = null;
          fileContentDiv.textContent = 'No file loaded yet.';
          chatOutput.innerHTML = '';
        }
      }
      renderTabs();
    }

    // Chat history rendering
    function renderChatHistory(history) {
      chatOutput.innerHTML = '';
      history.forEach(({ message, isUser }) => {
        appendMessageToChatOutput(message, isUser);
      });
      chatOutput.scrollTop = chatOutput.scrollHeight;
    }

    function appendMessageToChatOutput(message, isUser) {
      const msgDiv = document.createElement('div');
      msgDiv.style.textAlign = isUser ? 'right' : 'left';
      msgDiv.style.margin = '6px 0';

      const p = document.createElement('p');
      p.textContent = message;
      p.style.display = 'inline-block';
      p.style.padding = '8px 12px';
      p.style.borderRadius = '8px';
      p.style.maxWidth = '70%';
      p.style.backgroundColor = isUser ? '#007bff' : '#eee';
      p.style.color = isUser ? 'white' : 'black';

      msgDiv.appendChild(p);
      chatOutput.appendChild(msgDiv);
      chatOutput.scrollTop = chatOutput.scrollHeight;
    }

    function addMessageToCurrentChat(message, isUser) {
      if (!currentTabId) return;
      const tab = tabs.find(t => t.id === currentTabId);
      if (!tab) return;
      tab.chatHistory.push({ message, isUser });
      appendMessageToChatOutput(message, isUser);
    }
    // Drag & drop handlers
    dropArea.addEventListener('click', () => fileInput.click());

    dropArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropArea.classList.add('dragover');
    });
    dropArea.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropArea.classList.remove('dragover');
    });
    dropArea.addEventListener('drop', (e) => {
      e.preventDefault();
      dropArea.classList.remove('dragover');
      if (e.dataTransfer.files.length > 0) {
        handleFile(e.dataTransfer.files[0]);
      }
    });

    fileInput.addEventListener('change', (e) => {
      if (fileInput.files.length > 0) {
        handleFile(fileInput.files[0]);
      }
    });

    // Send message to backend AI
    async function sendMessageToBot(userInput) {
      if (!currentTabId) {
        alert('Please upload a file first!');
        return;
      }
      const tab = tabs.find(t => t.id === currentTabId);
      if (!tab) {
        alert('Invalid tab selected!');
        return;
      }
      if (!tab.modelSelected) {
        alert('Model not ready yet for this session. Please wait.');
        return;
      }
      if (!tab.content.trim()) {
        alert('File content is empty!');
        return;
      }

      addMessageToCurrentChat(userInput, true);
      addMessageToCurrentChat('ü§ñ...', false);

      try {
        const response = await fetch('http://127.0.0.1:5000/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: tab.sessionId,
            message: userInput,
            fileContent: tab.content
          })
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();

        // Replace last bot "thinking" message with actual response
        tab.chatHistory.pop();
        chatOutput.lastChild.remove();

        addMessageToCurrentChat(data.response || '(No response)', false);
      } catch (err) {
        // Replace last bot "thinking" message with error
        tab.chatHistory.pop();
        chatOutput.lastChild.remove();

        addMessageToCurrentChat(`‚ùå Error: ${err.message}`, false);
      }
    }

    // Send prompt
    function sendPrompt() {
      const prompt = aiInput.value.trim();
      if (!prompt) return;
      aiInput.value = '';
      sendMessageToBot(prompt);
    }

    sendButton.addEventListener('click', sendPrompt);
    aiInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendPrompt();
      }
    });

  </script>
</body>

</html>